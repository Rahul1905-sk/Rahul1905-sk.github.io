import{r as g}from"./react-c1a9316a.js";const I=new Map,b=new WeakMap;let A=0,$;function x(e){return e?(b.has(e)||(A+=1,b.set(e,A.toString())),b.get(e)):"0"}function M(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?x(e.root):e[t]}`).toString()}function O(e){let t=M(e),n=I.get(t);if(!n){const o=new Map;let c;const i=new IntersectionObserver(s=>{s.forEach(r=>{var u;const l=r.isIntersecting&&c.some(d=>r.intersectionRatio>=d);e.trackVisibility&&typeof r.isVisible>"u"&&(r.isVisible=l),(u=o.get(r.target))==null||u.forEach(d=>{d(l,r)})})},e);c=i.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),n={id:t,observer:i,elements:o},I.set(t,n)}return n}function T(e,t,n={},o=$){if(typeof window.IntersectionObserver>"u"&&o!==void 0){const u=e.getBoundingClientRect();return t(o,{isIntersecting:o,target:e,intersectionRatio:typeof n.threshold=="number"?n.threshold:0,time:0,boundingClientRect:u,intersectionRect:u,rootBounds:u}),()=>{}}const{id:c,observer:i,elements:s}=O(n);let r=s.get(e)||[];return s.has(e)||s.set(e,r),r.push(t),i.observe(e),function(){r.splice(r.indexOf(t),1),r.length===0&&(s.delete(e),i.unobserve(e)),s.size===0&&(i.disconnect(),I.delete(c))}}function m({threshold:e,delay:t,trackVisibility:n,rootMargin:o,root:c,triggerOnce:i,skip:s,initialInView:r,fallbackInView:u,onChange:l}={}){var d;const[v,V]=g.useState(null),h=g.useRef(),[R,S]=g.useState({inView:!!r,entry:void 0});h.current=l,g.useEffect(()=>{if(s||!v)return;let a;return a=T(v,(E,y)=>{S({inView:E,entry:y}),h.current&&h.current(E,y),y.isIntersecting&&i&&a&&(a(),a=void 0)},{root:c,rootMargin:o,threshold:e,trackVisibility:n,delay:t},u),()=>{a&&a()}},[Array.isArray(e)?e.toString():e,v,c,o,i,s,n,u,t]);const w=(d=R.entry)==null?void 0:d.target,p=g.useRef();!v&&w&&!i&&!s&&p.current!==w&&(p.current=w,S({inView:!!r,entry:void 0}));const f=[V,R.inView,R.entry];return f.ref=f[0],f.inView=f[1],f.entry=f[2],f}export{m as u};
